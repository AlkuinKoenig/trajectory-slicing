"0","sliced_df_CHC_last = sliced_df_CHC %>%"
"0","  dplyr::group_by(ID, slice_position)%>%"
"0","  #dplyr::arrange(ID,slice_position,hour_along_wmean)%>%"
"0","  dplyr::filter(hour_along_wmean == max(hour_along_wmean))%>% # getting the last crossing per slice. Note that the ""maximum"" is calculated for each group (defined by ID and slice position) separately"
"0","  dplyr::ungroup()"
"0",""
"0",""
"0","#The sliced data is in long format (many rows, few columns). We need a wide format (few rows, many columns) for clustering."
"0",""
"0","sliced_df_CHC_last_wide = sliced_df_CHC_last %>%"
"0","  dplyr::select(ID, slice_position, angle_wmean, hour_along_wmean, height_wmean)%>%"
"0","  tidyr::pivot_wider(id_cols = ""ID"", names_from = slice_position, values_from = c(""angle_wmean"", ""hour_along_wmean"", ""height_wmean""),"
"0","                     names_glue= ""{slice_position}__{.value}"")%>%"
"0","  dplyr::arrange(ID)%>%"
"0","  na.omit()#NAs are bad for clustering. In essence, this na.omit means that we're only taking the trajectory that crossed each slice at least once. "
"0","  #I'll normalize by computing the z-score. Take into account that different functions have to be used for the circular variable ""angle"" and the non-circular variable ""hour"""
"0",""
"0","  # "
"0","  # dplyr::mutate(across(.cols = contains(""angle""), "
"0","  #                      .fns = function(x){(x-circul)}"
"0","  #                      "
"0","  #                      "
"0","  #                      .fns = function(x){x/((sd.circular(x)*360/2/pi)^2)}))%>% # normalizing by division through the variance (standard deviation squared). Note that sd.circular returns the circular standard deviation in radians!"
"0","  # dplyr::mutate(across(.cols = contains(""hour_along""), .fns = function(x){x/(sd(x)^2)}))%>% # normalizing by division through the variance (standard deviation squared)"
"0","  # {.}"
"0","    "
"0","head(sliced_df_CHC_last_wide)"
