% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fun_get_slice_crossing_df.R
\name{get_slice_crossing_df}
\alias{get_slice_crossing_df}
\title{get_slice_crossing_df}
\usage{
get_slice_crossing_df(
  traj_df,
  slice_type = "radial",
  slice_position,
  ID_columns = c("ID"),
  extra_vars = c("height"),
  delta_filter = 10
)
}
\arguments{
\item{traj_df}{<data.frame> a data frame containing the trajectory information. The following columns MUST be present.
1: ID columns that (see below under "ID_columns")
2: lat_i: <numeric> latitude of trajectory emission
3: lon_i: <numeric> longitude of trajectory emission
4: hour_along: <numeric> hours since trajectory emission. If not 0, this should be negative for back trajectories and positive for forward trajectories
5: If "radial slices" are to be computed: radius: <numeric> radius from trajectory endpoint to radial center (point of emission).
6: "" "" "": angle: <circular> angle between trajectory endpoing and radial center (point of emission)
7: all additional columns specified in "extra_vars"

For "radial slices", the user should calculate the "radius" and "angle" columns beforehand. This is not done within the function.
If necessary, the user should also rename the columns of the input trajectory data frame accordingly (e.g. "longitude" --> "lon").}

\item{slice_type}{<one of c("radial","latitudinal","longitudinal")>
If "radial": Find where a trajectory crossed a circle (usually centerd on the point of emission)
If "latitudinal": Find where a trajectory crossed a certain latitude (for example 0, the equator)
If "longitudinal": Find where a trajectory crossed a certain longitude}

\item{slice_position}{<numeric vector> for which values should the slices be computed?
Interpreted as radius if slice_type == "radial", as latitude if slice_type == "latitudinal", and as longitude if slice_type == "longitudinal"}

\item{ID_columns}{<undefined type> The name of one (or several) columns to be used as ID for each trajectory. Each trajectory should correspond to
a unique combination of values in the ID columns. For example, if trajectories were released from one single emission point, then the time of
emission could be used as ID, like ID_columns = c("time_of_emission") (note that this is a placeholder name).
If you also emitted trajectories from different altitudes, for example, then at least one column should represent this
information, e.g. ID_columns = c("time_of_emission","altitude_of_emission")}

\item{extra_vars}{<character vector> column names of any additional variables for which the value at slice crossing should be computed. For example: c("air_temp","sp_humidity")}

\item{delta_filter}{<numeric> filtering parameter to speed up computation. The idea is to only look at rows that are "close" to the slice that is to be crossed.
You generally want delta_filter to correspond to the maximum distance (in longitude, latitude, or radius) that you expect a trajectory to cross within one time step.
Ideally, you would check an adequate value before using this function, but for HYSPLIT and hourly endpoints, ~ 3 is usually safe.}
}
\value{
<data.frame> A data.frame with information on where a slice was crossed:
1: How was the slice crossed? <one of c("decreasing","increasing","no crossing")>.
  a) "decreasing" means that the trajectory passed from "larger than the slice position" to "lower than the slice position".
    For example, in "radial" this would correspond to a trajectory moving closer to the radial centerpoint (usually point of emission).
  b) "increasing" means the opposite of decreasing.
  c) "no crossing" means that the trajectory defined by c(ID_location, ID_time) did not cross the respective slice.
    This information comes in handy for normalization.
2: the mean coordinates (and additional variable values) at slice crossing. "wmean" means weighted mean, which is calculated by default.
}
\description{
get_slice_crossing_df
}
